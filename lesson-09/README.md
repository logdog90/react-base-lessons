### Работа со списками и алгоритм согласования
Алгоритм сравнения или согласования. React сравнивает деревья начиная с их корневых элементов и направляется вниз. Сравниваются типы (теги) корневых элементов.
Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Трансформация из `<ul>` в `<div>`, или из `<li>` в `<span>`
```
<ul className="app-list list-group">
  <li className="list-group-item d-flex justify-content-between"></li>
  <li className="list-group-item d-flex justify-content-between"></li>
  <li className="list-group-item d-flex justify-content-between"></li>
</ul>
```

```
<div className="app-list list-group">
  <span className="list-group-item d-flex justify-content-between"></span>
  <span className="list-group-item d-flex justify-content-between"></span>
  <span className="list-group-item d-flex justify-content-between"></span>
</div>
```
приведут к полному перестроению вложенных элементов.

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Например:
```
<div className="before" title="stuff"><div/>

<div className="after" title="stuf><div/>
```
Сравнивая эти элементы, React знает, что нужно модифицировать только className у DOM-узла.

По умолчанию при обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков и создаёт мутацию, когда находит отличие.
Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично.
React сравнит каждый элемент DOM-дерева и в конец добавит нужный элемент не перерисовывая родителя.
```
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```
При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо.

React, вместо того чтобы оставить `<li>Санкт-Петербург</li>`  и `<li>Москва</li>` нетронутыми, будет мутировать каждого потомка. Эта неэффективность может стать проблемой.

Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React воспользуется ими, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить key к неэффективному примеру выше, преобразование дерева станет эффективнее.
```
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```
Теперь React знает, что элемент с ключом '2014' — новый, а элементы с ключами '2015' и '2016' нужно переместились вниз.

Для того чтобы React знал, где какой элемент в приложении из данного урока, я добавил id, и в свойство key передал его.
Воспользовался частичной деструктуризацией.
```
const data = [
  { id: 1, name: 'Башлак Евгений', salary: '100 000', increase: true },
  { id: 2, name: 'Балтабаев Максим', salary: '60 000', increase: false },
  { id: 3, name: 'Волковский Андрей', salary: '50 000', increase: false }
]

const EmployeesList = ({ data }) => {
  const employees = data.map(employee => {
    const { id, ...itemEmployee } = employee

    return (
      <EmployeesListItem key={ id } {...itemEmployee } />
    );
  });

  return (
    <ul className="app-list list-group">
      { employees }
    </ul>
  );
};
```